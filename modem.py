from binascii import unhexlify

_sine_table = [
0x80,0x81,0x83,0x84,0x86,0x87,0x89,0x8A,0x8C,0x8D,0x8F,0x91,0x92,0x94,0x95,0x97,
0x98,0x9A,0x9B,0x9D,0x9E,0xA0,0xA1,0xA3,0xA4,0xA6,0xA7,0xA9,0xAA,0xAC,0xAD,0xAF,
0xB0,0xB2,0xB3,0xB4,0xB6,0xB7,0xB9,0xBA,0xBB,0xBD,0xBE,0xBF,0xC1,0xC2,0xC3,0xC5,
0xC6,0xC7,0xC9,0xCA,0xCB,0xCC,0xCE,0xCF,0xD0,0xD1,0xD2,0xD4,0xD5,0xD6,0xD7,0xD8,
0xD9,0xDA,0xDB,0xDD,0xDE,0xDF,0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE6,0xE7,0xE8,
0xE9,0xEA,0xEB,0xEC,0xEC,0xED,0xEE,0xEF,0xF0,0xF0,0xF1,0xF2,0xF2,0xF3,0xF4,0xF4,
0xF5,0xF5,0xF6,0xF7,0xF7,0xF8,0xF8,0xF9,0xF9,0xF9,0xFA,0xFA,0xFB,0xFB,0xFB,0xFC,
0xFC,0xFC,0xFD,0xFD,0xFD,0xFD,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,
0xFF,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFD,0xFD,0xFD,0xFD,0xFC,
0xFC,0xFC,0xFB,0xFB,0xFB,0xFA,0xFA,0xF9,0xF9,0xF9,0xF8,0xF8,0xF7,0xF7,0xF6,0xF5,
0xF5,0xF4,0xF4,0xF3,0xF2,0xF2,0xF1,0xF0,0xF0,0xEF,0xEE,0xED,0xEC,0xEC,0xEB,0xEA,
0xE9,0xE8,0xE7,0xE6,0xE6,0xE5,0xE4,0xE3,0xE2,0xE1,0xE0,0xDF,0xDE,0xDD,0xDB,0xDA,
0xD9,0xD8,0xD7,0xD6,0xD5,0xD4,0xD2,0xD1,0xD0,0xCF,0xCE,0xCC,0xCB,0xCA,0xC9,0xC7,
0xC6,0xC5,0xC3,0xC2,0xC1,0xBF,0xBE,0xBD,0xBB,0xBA,0xB9,0xB7,0xB6,0xB4,0xB3,0xB2,
0xB0,0xAF,0xAD,0xAC,0xAA,0xA9,0xA7,0xA6,0xA4,0xA3,0xA1,0xA0,0x9E,0x9D,0x9B,0x9A,
0x98,0x97,0x95,0x94,0x92,0x91,0x8F,0x8D,0x8C,0x8A,0x89,0x87,0x86,0x84,0x83,0x81,
0x80,0x7E,0x7C,0x7B,0x79,0x78,0x76,0x75,0x73,0x72,0x70,0x6E,0x6D,0x6B,0x6A,0x68,
0x67,0x65,0x64,0x62,0x61,0x5F,0x5E,0x5C,0x5B,0x59,0x58,0x56,0x55,0x53,0x52,0x50,
0x4F,0x4D,0x4C,0x4B,0x49,0x48,0x46,0x45,0x44,0x42,0x41,0x40,0x3E,0x3D,0x3C,0x3A,
0x39,0x38,0x36,0x35,0x34,0x33,0x31,0x30,0x2F,0x2E,0x2D,0x2B,0x2A,0x29,0x28,0x27,
0x26,0x25,0x24,0x22,0x21,0x20,0x1F,0x1E,0x1D,0x1C,0x1B,0x1A,0x19,0x19,0x18,0x17,
0x16,0x15,0x14,0x13,0x13,0x12,0x11,0x10,0x0F,0x0F,0x0E,0x0D,0x0D,0x0C,0x0B,0x0B,
0x0A,0x0A,0x09,0x08,0x08,0x07,0x07,0x06,0x06,0x06,0x05,0x05,0x04,0x04,0x04,0x03,
0x03,0x03,0x02,0x02,0x02,0x02,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x02,0x03,
0x03,0x03,0x04,0x04,0x04,0x05,0x05,0x06,0x06,0x06,0x07,0x07,0x08,0x08,0x09,0x0A,
0x0A,0x0B,0x0B,0x0C,0x0D,0x0D,0x0E,0x0F,0x0F,0x10,0x11,0x12,0x13,0x13,0x14,0x15,
0x16,0x17,0x18,0x19,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x24,0x25,
0x26,0x27,0x28,0x29,0x2A,0x2B,0x2D,0x2E,0x2F,0x30,0x31,0x33,0x34,0x35,0x36,0x38,
0x39,0x3A,0x3C,0x3D,0x3E,0x40,0x41,0x42,0x44,0x45,0x46,0x48,0x49,0x4B,0x4C,0x4D,
0x4F,0x50,0x52,0x53,0x55,0x56,0x58,0x59,0x5B,0x5C,0x5E,0x5F,0x61,0x62,0x64,0x65,
0x67,0x68,0x6A,0x6B,0x6D,0x6E,0x70,0x72,0x73,0x75,0x76,0x78,0x79,0x7B,0x7C,0x7E,
]

class AFSK():
    bc = 0
    High = 0
    phase = 0
    APRS_Preemphasis = 0

    def __init__(self, sample_rate = 48000, baud = 1200, lfreq = 1200, hfreq = 2200):
        self.sample_rate = sample_rate
        self.baud = baud
        self.lfreq = lfreq
        self.hfreq = hfreq
        self.cycles_per_bit = self.sample_rate / self.baud
        self.cycles_per_byte = self.cycles_per_bit * 8
        self.buffer = []

    def saveToFile(self, filename):
        with open(filename, "wb") as f:
            f.write(bytearray(self.buffer))
        self.buffer = []

    def encode(self, Messages):
        preamble_length = 128
        postamble_length = 64
        flags_before = 32
        flags_after = 32

        if isinstance(Messages, list):
            message_count = len(Messages)
        else:
            message_count = 1
            Messages = [Messages]
        total_message_length = sum([len(x.toString()) for x in Messages])

        # Calculate size of file
        total_cycles = (self.cycles_per_byte * total_message_length) + (self.cycles_per_byte * (flags_before + flags_after) * message_count) + ((preamble_length + postamble_length) * self.cycles_per_bit * message_count)

        # Make header
        header = self.wavhdr(total_cycles * 2 + 10)  # *2 + 10 is new
        # Write wav header
        #f.write(''.join(header)
        self.buffer += header

        for j in range(message_count):
            msg = Messages[j].toString()
            message_length = len(msg)
            # Write preamble
            for i in range(preamble_length):
		        self.make_and_write_freq(0)

            for i in range(flags_before):
                self.make_and_write_byte( 0x7E, 0) #######

            # Create and write actual data
            for i in range(message_length):
                self.make_and_write_byte( msg[i], 1)

            for i in range(flags_after):
                self.make_and_write_byte( 0x7E, 0)

            # Write postamble
            for i in range(postamble_length):
                self.make_and_write_freq(0)
        for i in range(10):
            self.buffer += [0, 0, 0, 0]

    # Makes 44 - byte header for 8 - bit WAV in memory
    # usage: wavhdr(pointer, sampleRate, dataLength)
    def wavhdr(self, dlen):
        rv = []
        rv += ['R', 'I', 'F', 'F']
        rv += list(unhexlify("%08x" % (dlen + 44)))[::-1]  # len
        rv += ['W', 'A', 'V', 'E']  # wav
        rv += ['f', 'm', 't', ' ']  # fnt
        rv += list(unhexlify("%08x" % 0x10))[::-1]  # flen
        rv += list(unhexlify("%04x" % 1))[::-1]  # one
        rv += list(unhexlify("%04x" % 1))[::-1]  # chan
        rv += list(unhexlify("%08x" % self.sample_rate))[::-1]  # hz
        rv += list(unhexlify("%08x" % self.sample_rate))[::-1]  # bpsec
        rv += list(unhexlify("%04x" % 1))[::-1]  # bpsmp
        rv += list(unhexlify("%04x" % 16))[::-1]  # bitpsmp
        rv += ['d', 'a', 't', 'a']  # dat
        rv += list(unhexlify("%08x" % dlen))[::-1]  # dlen
        return rv


    def make_and_write_freq(self, High):
        # write 1 bit, which will be several values from the sine wave table
        if High:
            step = (512 * self.hfreq << 7) / (self.cycles_per_bit * self.baud)
        else:
            step = (512 * self.lfreq << 7) / (self.cycles_per_bit * self.baud)

        for i in range(self.cycles_per_bit):
            # fwrite( & (_sine_table[(phase >> 7) & 0x1FF]), 1, 1, f);
            v = _sine_table[(self.phase >> 7) & 0x1FF] * 0x80 - 0x4000
            if High and self.APRS_Preemphasis:
                v *= 0.65
            else:
                v *= 1.3

            # int16_t v = _sine_table[(phase >> 7) & 0x1FF] * 0x100 - 0x8000;
            v = int(v)
            self.buffer += [ (v & 0xff),((v >> 8) & 0xff)]
            self.phase += step

    def make_and_write_bit(self, Bit, BitStuffing):
        if (BitStuffing):
            if (self.bc >= 5):
                self.High = not self.High
                self.make_and_write_freq(self.High)
                self.bc = 0

        else:
            self.bc = 0

        if Bit:
            # Stay with same frequency, but only for a max of 5 in a row
            self.bc += 1
        else:
            # 0 means swap frequency
            self.High = not self.High
            self.bc = 0
        self.make_and_write_freq( self.High)

    def make_and_write_byte(self, Character, BitStuffing):
        if isinstance(Character, str):
            Character = ord(Character)
        for i in range(8):
            self.make_and_write_bit( Character & 1, BitStuffing)
            Character >>= 1
